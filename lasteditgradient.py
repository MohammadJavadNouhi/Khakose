# -*- coding: utf-8 -*-
"""LastEditGradient.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jnMWqP9-ErXN2HJPdqvFMC1JMsyeWOn9
"""

from numba import njit
import numpy as np
import matplotlib.pyplot as plt
import scipy
from scipy import stats
import math
import csv
from scipy.optimize import curve_fit
from google.colab import files


def test_displacement_for_D(p, alpha):
    global m
    if p[0] == 1 and p[1] == 1 and p[2] == 1 and alpha == 0:
        p[0] = 0
        m = 1
    elif p[0] == 1 and p[1] == 1 and p[2] == 1 and alpha == 1:
        p[1] = 0
        m = 2
    elif p[0] == 1 and p[1] == 1 and p[2] == 1 and alpha == 2:
        p[2] = 0
        m = 3
    elif p[0] == 0 and p[1] == 0 and p[2] == 0 and alpha == 0:
        p[0] = 1
        m = 4
    elif p[0] == 0 and p[1] == 0 and p[2] == 0 and alpha == 1:
        p[1] = 1
        m = 5
    elif p[0] == 0 and p[1] == 0 and p[2] == 0 and alpha == 2:
        p[2] = 1
        m = 6
    elif p[0] == 0 and p[1] == 1 and p[2] == 1 and alpha == 0:
        p[0] = 1
        m = 7
    elif p[0] == 1 and p[1] == 0 and p[2] == 1 and alpha == 1:
        p[1] = 1
        m = 8
    elif p[0] == 1 and p[1] == 1 and p[2] == 0 and alpha == 2:
        p[2] = 1
        m = 9
    elif p[0] == 0 and p[1] == 1 and p[2] == 1 and alpha == 1:
        p[1] = 0
        m = 10
    elif p[0] == 1 and p[1] == 0 and p[2] == 1 and alpha == 2:
        p[2] = 0
        m = 11
    elif p[0] == 1 and p[1] == 1 and p[2] == 0 and alpha == 0:
        p[0] = 0
        m = 12
    elif p[0] == 0 and p[1] == 1 and p[2] == 1 and alpha == 2:
        p[2] = 0
        m = 13
    elif p[0] == 1 and p[1] == 0 and p[2] == 1 and alpha == 0:
        p[0] = 0
        m = 14
    elif p[0] == 1 and p[1] == 1 and p[2] == 0 and alpha == 1:
        p[1] = 0
        m = 15
    elif p[0] == 1 and p[1] == 0 and p[2] == 0 and alpha == 0:
        p[0] = 0
        m = 16
    elif p[1] == 1 and p[2] == 0 and p[0] == 0 and alpha == 1:
        p[1] = 0
        m = 17
    elif p[2] == 1 and p[0] == 0 and p[1] == 0 and alpha == 2:
        p[2] = 0
        m = 18
    elif p[0] == 1 and p[1] == 0 and p[2] == 0 and alpha == 1:
        p[1] = 1
        m = 19
    elif p[1] == 1 and p[2] == 0 and p[0] == 0 and alpha == 2:
        p[2] = 1
        m = 20
    elif p[2] == 1 and p[0] == 0 and p[1] == 0 and alpha == 0:
        p[0] = 1
        m = 21
    elif p[1] == 0 and p[0] == 1 and p[2] == 0 and alpha == 2:
        p[2] = 1
        m = 22
    elif p[2] == 0 and p[0] == 0 and p[1] == 1 and alpha == 0:
        p[0] = 1
        m = 23
    elif p[0] == 0 and p[1] == 0 and p[2] == 1 and alpha == 1:
        p[1] = 1
        m = 24

    return m



Dm_new = np.array([[-7.1003e-01 ,  8.6198e-18 ,  2.6255e-18],
                   [3.5501e-01 , -6.1490e-01 ,  3.3307e-17],
                   [3.5501e-01  , 6.1490e-01 , -6.6613e-17],
                   [7.3318e-01 , -8.9715e-19 ,  1.8817e-18],
                   [-3.6659e-01  , 6.3495e-01 ,  1.2688e-16],
                   [-3.6659e-01 , -6.3495e-01 , -2.2204e-16],
                   [7.1001e-01 ,  5.8308e-18 ,  3.3931e-19],
                   [-3.5501e-01 ,  6.1489e-01 ,  5.5511e-17],
                   [-3.5501e-01 , -6.1489e-01 , -7.7716e-17],
                   [3.7028e-01 , -6.2710e-01 ,  8.6936e-03],
                   [3.5794e-01 ,  6.3422e-01 ,  8.6936e-03],
                   [-7.2822e-01 , -7.1219e-03 ,  8.6948e-03],
                   [3.7028e-01 ,  6.2710e-01 , -8.6936e-03],
                   [-7.2822e-01 ,  7.1219e-03 , -8.6948e-03],
                   [3.5794e-01 , -6.3422e-01 , -8.6936e-03],
                   [-7.3319e-01 , -7.4206e-18 ,  1.5067e-18],
                   [3.6660e-01 , -6.3496e-01 ,  4.7581e-17],
                   [3.6660e-01 ,  6.3496e-01 ,  1.5860e-17],
                   [-3.6343e-01 ,  6.3108e-01 ,  8.6942e-03],
                   [-3.6481e-01 , -6.3028e-01 ,  8.6942e-03],
                   [ 7.2825e-01 , -7.9659e-04 ,  8.6929e-03],
                   [-3.6343e-01 , -6.3108e-01 , -8.6942e-03],
                   [ 7.2825e-01  , 7.9659e-04 , -8.6929e-03],
                   [-3.6481e-01 ,  6.3028e-01 , -8.6942e-03]])

dis = Dm_new.T
"""

Dm_new = np.array([[-3.6096e-02 ,  4.4441e-19  , 3.1153e-19],
                  [ 1.8048e-02 , -3.1260e-02 , -3.4694e-18],
                  [ 1.8048e-02  , 3.1260e-02 ,  1.3878e-18],
                  [ 3.5655e-02  , 4.7120e-19  , 4.3876e-19],
                  [-1.7827e-02 ,  3.0878e-02 , -1.4869e-18],
                  [-1.7827e-02 , -3.0878e-02 ,  2.4782e-18],
                  [3.4656e-02 ,  4.4627e-19,  -1.4368e-19],
                  [-1.7328e-02 ,  3.0013e-02  , 1.0408e-18],
                  [-1.7328e-02 , -3.0013e-02 , -2.0817e-18],
                  [1.8540e-02 , -3.2060e-02 ,  3.9789e-04],
                  [1.8494e-02 ,  3.2086e-02 ,  3.9789e-04],
                  [-3.7035e-02 , -2.6410e-05 ,  3.9791e-04],
                  [1.8540e-02 ,  3.2060e-02 , -3.9789e-04],
                  [-3.7035e-02 ,  2.6410e-05 , -3.9791e-04],
                  [1.8494e-02 , -3.2086e-02 , -3.9789e-04],
                  [-3.7384e-02 ,  3.2377e-20 , -8.9083e-20],
                  [1.8692e-02 , -3.2376e-02 ,  1.9825e-18],
                  [1.8692e-02 ,  3.2376e-02 , -1.9825e-18],
                  [-1.7419e-02  , 3.0966e-02 ,  4.6905e-04],
                  [-1.8108e-02 , -3.0568e-02 ,  4.6905e-04],
                  [3.5526e-02 , -3.9767e-04 ,  4.6903e-04],
                  [-1.7419e-02 , -3.0966e-02 , -4.6905e-04],
                  [3.5526e-02 ,  3.9767e-04 , -4.6903e-04],
                  [-1.8108e-02 ,  3.0568e-02 , -4.6905e-04]])

dis = Dm_new.T
"""

#@njit
def getOrientedAction(state,ratio,rotation,grad):
     #TODO *ratio
    #t=1 if state=0 and t = ratio if state = 1
    # print(np.dot(rotation,r0.T).T,cGrad)
    # print(np.dot(np.dot(rotation,r0.T).T,cGrad))

    r0 = np.array([[0,0],
                  [15, -10*np.sqrt(3)/2],
                  [15, 10*np.sqrt(3)/2],
                  [10 , 0]])


    rotation = np.array([[np.cos(rotation),-np.sin(rotation)],
                         [np.sin(rotation),np.cos(rotation)]])

    grad = np.array([grad , 0.])


    #ratios = ratio + np.dot(np.dot(rotation,r0[1:].T).T,grad)
    #ratios = ratio + np.dot(r0[1:],grad)
    ratios = ratio + np.dot(grad,np.dot(rotation,r0[1:].T))

    t1,t2,t3 = np.where(state==0,np.ones(3),ratios[::-1])
    sum = t1 * t2 + t1 * t3 + t2 * t3

    # probs = np.array([t2*t3*t4/sum,t1*t3*t4/sum,t1*t2*t4/sum,t2*t3*t1/sum])
    randomNumber = np.random.uniform(0, 1, 1)

    if randomNumber <= t2 * t3 / sum:
        changingJoint = 0
    elif (randomNumber <= (t2 * t3 + t1 * t3) / sum):
        changingJoint = 1
    else:
        changingJoint = 2

    # changingJoint = np.random.choice(np.arange(4),p=probs)
    # action = np.concatenate((state,changingJoint.reshape((1,))),axis=0)

    #if state[changingJoint] == 0:
        #deltat = ratio
    #else:
        #deltat = 1
    deltat = 1/(1/t1 + 1/t2 + 1/t3)


    return changingJoint, deltat




def doOrientedStep(state,ratio,rotation,grad):
    action,deltat = getOrientedAction(state,ratio,rotation,grad)
    new_state = state.copy()
    new_state[action] = 1 - new_state[action]
    return action , new_state , deltat



def Orientedperturbe(perturbingSteps,ratio,grad):
    time = 0
    pertrubingPose = np.array([0.,0.])
    perturbingRotation = np.array([0.])
    #state = np.ones(4,dtype=np.int64)
    state = np.ones(3)
    #print(state)
    pertrubingPoses = np.zeros((perturbingSteps, 2))
    pertrubingTimes = np.zeros(perturbingSteps)

    for t in range(perturbingSteps):
        action, newState, deltat = doOrientedStep(state,ratio,perturbingRotation[0],grad)
        # Edit of the code for calculating the Rcm
        number_config = test_displacement_for_D(state, action)
        #print(number_config)
        state = newState
        pertrubingPose += np.array([dis[0, number_config - 1] * np.cos(perturbingRotation[0]) - dis[1, number_config - 1] * np.sin(perturbingRotation[0]),dis[0, number_config - 1] * np.sin(perturbingRotation[0]) + dis[1, number_config - 1] * np.cos(perturbingRotation[0])])
        perturbingRotation += np.array([dis[2, number_config - 1]])
        #print(perturbingRotation)
        #print(pertrubingPose)
        pertrubingPoses[t] = pertrubingPose
        time += deltat
        #print(time)
        pertrubingTimes[t] = time
    return pertrubingPoses, pertrubingTimes



def getOrientedPerturbingDiffusionCoefForRatio(ratio,grad,iterations = 1000,perturbingSteps = 1000):
    # iterations = 10_00
    # perturbingSteps = 10_00
    meanFinalPoses = np.zeros((perturbingSteps))
    meanFinalTimes = np.zeros(perturbingSteps)
    for iteration in range(iterations):
        pertrubingPoses,pertrubingTimes = Orientedperturbe(perturbingSteps,ratio,grad)
        #print(np.sum(np.square(pertrubingPoses[:]),axis=1).shape,meanFinalPoses.shape)
        meanFinalPoses += pertrubingPoses[:,0]
        meanFinalTimes += pertrubingTimes
        #print(iteration)

    # plt.plot(meanFinalTimes,meanFinalPoses)
    # plt.show()

    # return slope  #*some Coef
    return meanFinalTimes/iterations,-meanFinalPoses/iterations

def getOrientedPerturbingDiffusionCoef(ratio,grads,iterations = 1000,perturbingSteps = 1000):
    diffs =np.zeros(grads.shape)
    errors = np.zeros(grads.shape[0])
    for i in range(grads.shape[0]):
        #print(i)
        meanFinalTimes,meanFinalPoses= getOrientedPerturbingDiffusionCoefForRatio(ratio,grads[i],iterations,perturbingSteps)
        slope, intercept, r_value, p_value, std_err = scipy.stats.linregress(meanFinalTimes,meanFinalPoses)
        diffs[i] =  slope
        #errors[i] = std_err
    return diffs,errors


"""
def getOrientedPerturbingDiffusionCoef2(ratio,grads,iterations = 1000,perturbingSteps = 1000):
    f =np.zeros(grads.shape)
    errors = np.zeros(grads.shape[0])
    for i in range(grads.shape[0]):
        #print(i)
        vs = getOrientedPerturbingDiffusionCoef(ratio,grads,iterations,perturbingSteps)
        slope, intercept, r_value, p_value, std_err = scipy.stats.linregress(grads,vs)
        f[i] =  slope
        errors[i] = std_err
    return f,errors
"""

ratio = 1
grads = 10**(np.arange(-250,-150,20)/100)
vs,errors = getOrientedPerturbingDiffusionCoef(ratio,grads,15000,10000)
print(grads)
print(vs)
print(errors)

#plt.plot(np.log(grads),vs)
#plt.errorbar(grads, vs , yerr=errors , fmt="o")
plt.plot(grads,vs)
#ax.errorbar(np.log(ratios), diffs, yerr=errors,fmt='-o')

plt.xlabel(" gradient(ln(C)) ")
plt.ylabel("V")
plt.show()